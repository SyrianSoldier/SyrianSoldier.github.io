# 设计模式

## 设计模式的分类

设计模式可以分为三类：创建型模式、结构型模式和行为型模式。

1. 创建型模式（Creational Pattern）创建型模式关注的是对象的创建过程，目标是尽可能地将对象的创建和使用分离，从而达到解耦的目的。其中比较常见的有工厂模式、单例模式、建造者模式等。
2. 结构型模式（Structural Pattern）结构型模式关注的是对象的组成方式，目标是设计出符合要求的结构，让对象之间的关系更加清晰明了，从而降低耦合度，提高代码的可维护性和可扩展性。其中比较常见的有代理模式、装饰器模式、适配器模式等。
3. 行为型模式（Behavioral Pattern）行为型模式关注的是对象的行为和职责，目标是设计出各种对象之间的高效协作方式，从而达到实现复杂业务逻辑的目的。其中比较常见的有观察者模式、迭代器模式、策略模式等。

## 单例模式

> 定义: 保证一个类只有一个实例, 并且提供一个全局访问点

### 单例模式示意

```js
class Singleton {
    instance = null// 保存实例的属性

    static getInstance(args) {
        if (this.instance) {
            return this.instance
        }

        return this.instance = new Singleton(args)
    }
}

const obj1 = Singleton.getInstance('实例1')
const obj2 = Singleton.getInstance('实例2')

console.log(obj1 === obj2)

```

可以看出, 这种设置可以保证每次调用getInstance时候获取的都是一个对象.

但本身这个例子, 没有什么实际意义. 下面是一个是有意义的示例

=

### 透明单例 : 创建DIV单例

> 上面的单例模式的实现, 是对使用者不透明的. 什么意思呢? 使用者本来使用new...的方式创建一个类的示例, 但为了实现单例模式, 我们强行让用户使用getInstance方法创建对象
>
> 虽然这样达到了目标, 但是对于使用者来说, 增加了学习额外API的学习成本.
>
> 所谓的"透明的"实现就是要让使用者无感知, 使用者还是之前的用法, 但是我们已经加了一些功能. 在上个例子中, 就是用户还是new调用, 但是已经多了单例的功能



利用闭包+IIFE实现单例 : 一个只会创建一个DIV的例子

> 这个例子事项是想实现, 当new CreateDiv时候, 自动创建并添加DIV, 并依靠闭包, 缓存了实例

```js
const CreateDiv = (() => {
    let instance = null // 保存CreateDiv的示例

    class Create {
        div
        /**
          @param {string} divText div的文本
          @target {DOMNode} target 将div添加到哪个父节点
        */
        constructor(divText,target){
            if(instance) return instance
            this.divText = divText
            this.target = target
            this.init()
            instance = this
        }

        init(){
           // 创建div, 将其添加到父节点上
           this.div = document.createElement('div')
           this.div.innerText = this.divText
           this.target.appendChild(this.div)
            
        }
    }

    return Create
})();

const cd1 = new CreateDiv('你好',document.body)
const cd2 = new CreateDiv('HELLO',document.body)

console.log(cd1 === cd2)
```



### 代理模式实现CreateDiv

> 上面的代码可读性很差, 违反了单一职责原则. 既负责创建div又有单例的功能, 再加上闭包的写法, 对理解力是个不小的考验
>
> 将创建单例的功能抽出去, 单独抽成一个类, 这个类的作用就是代替原来CreateDiv, 并附加一个单例模式



> 代理类ProxyCreateDiv不返回自己本身类的实例, 而是返回CreateDiv的引用, 并且加了单例的功能

```js
class CreateDiv {
    div /**
          @param {string} divText div的文本
          @target {DOMNode} target 将div添加到哪个父节点
        */
    constructor(divText, target) {
        // if(instance) return instance //取消单例功能的代码
        this.divText = divText
        this.target = target
        this.init()
        // instance = this // 取消单例功能的代码
    }

    init() {
        // 创建div, 将其添加到父节点上
        this.div = document.createElement('div')
        this.div.innerText = this.divText
        this.target.appendChild(this.div)

    }
}

class ProxyCreateDiv {
    static instance; 
    
    constructor(...args) {
        if (ProxyCreateDiv.instance)
            return ProxyCreateDiv.instance

        return ProxyCreateDiv.instance = new CreateDiv(...args)
    }
}

const cd1 = new ProxyCreateDiv('你好',document.body)
const cd2 = new ProxyCreateDiv('HELLO',document.body)

console.log(cd1 === cd2)
```

### js中的单例模式

> 上面的实例都是通过class实现的, 但是前端开发中使用class实现类似功能是非常不常见的
>
> 这是由于设计模式最初是由后端语言者提出的, 很多demo都是使用后端的思考方式实现的, 在前端, 在js下如何实现单例模式呢

> 其实非常简单, 想想单例模式的定义: 全局只存在一个对象, 并且提供一个可访问的引用. 那么 const a = {} 其实就是一种单例模式
>
> 但是这种单例的实现有很多问题, 主要是污染全局变量, 随着对象越来越多, 那么可能出现命名重复的问题
>
> 下面是解决办法

### 命名空间解决全局污染

> 命名空间不能完全让全局没有单例, 但是可以大大减少全局的单例数

```js
const namespce1 = {
  person1:{}
  person2:{}
  //...
}

const namespce2 = {
  person1:{}
  person2:{}
  //...
}
```

通过不同的命名空间, 使得相同的单例不再冲突



### 动态命名空间

> 以上的命名空间, 需要手动实现. 可扩展性很差. 比如我想对上面namespace2添加一个变量person3, 就需要动源代码, 不是很好. 下面是一个动态创建命名空间的例子
>
> 看懂下面的代码需要一点点的算法技术(迭代法的应用, 也可以用递归..)

```js
const App = {} //假如全局下有个App对象
App.addNamespce = function(names){
  const namesArr = names.split('.') // 将dom.style--> ['dom','style']
  let current = App //记录添加的层级对象, 默认从App开始
  
  for(let i = 0; i < namesArr.length; i++){
    let name = namesArr[i]
    if(!current[name]){
      current[name] = {}
    }
    current = current[name] // 继续添加子命名空间
  }
}

App.addNamespce('Javascirpt')
App.addNamespce('CSS.Color')
App.addNamespce('CSS.Border')
// 输出App: 
{
    "Javascirpt": {},
    "CSS": {
        "Color": {},
        "Border": {}
    }
}
```



## 策略模式

>  策略模式是关于算法的模式(广义的算法, 指多个程序的运行逻辑)
>
>  策略模式需要有两部分组成 1. 一组策略类, 每个策略封装了具体的算法, 并提供名字相同的运行接口  2. Context类, 保存了所有策略 类的引用. 负责接受使用策  略者的调用, 委派给具体策略类运算.
>
>  策略模式可以取消大量的if..else嵌套逻辑



### Typescript实现策略模式

> 由于策略模式的后端实现需要抽象类/接口, js并不支持抽象类.接口, 所以使用ts实现策略模式. 在下个例子会举出js的实现, 更贴近前端开发场景

> 下面是购物车结算相关的例子
>
> 在一个购物车结算的场景下, 我们可能有各种不同结算方式, 比如原价结算, 比如打7折计算, 比如优惠券减免. 这组成了一组算法, 也就是我们定义中的一组策略类
>
> 另外我们需要一个Context类, 负责将使用者的请求委派给具体的策略类, 起一个中转

```typescript
// 所有的策略类都需要一个结算的方法
// 使用接口约束
interface ShopCartStrategy { 
  settleAccounts(price:number): number
}

// 打七折的策略类
class DiscountStrategy implements ShopCartStrategy { 
  settleAccounts(price:number) { 
    return price * 0.7
  }
}

// 优惠券策略
class CouponStrategy implements ShopCartStrategy {
  coupon: number 
  
  constructor(coupon:number) { 
    this.coupon = coupon
  }
  settleAccounts(price:number) { 
    return price - this.coupon
  }
}

// 普通结算
class CommonStrategy implements ShopCartStrategy { 
  settleAccounts(price:number) { 
    return price
  }
}

class SeetleContext { 
  getPrice(strategyType: string,price:number,counpon?:number):number { 
    let strategy:ShopCartStrategy = new CommonStrategy() //默认普通结算
    switch (strategyType) {
      case 'discount': // 打折计算
        strategy = new DiscountStrategy() 
        break;
      case 'coupon': // 优惠券计算
        counpon && (strategy = new CouponStrategy(counpon))
        break;
      default:
        break;
    }
    return strategy.settleAccounts(price)
  }
}

// 使用者
new SeetleContext().getPrice('common',1000)
new SeetleContext().getPrice('discount',1000)
new SeetleContext().getPrice('coupon',1000,200)
```

### JS实现策略模式

> 由于在JS中, 函数是一等公民和创建对象的便利性.  我们不必用class声明, 下面用js重构上面的购物车例子

```js
// 策略组
const strategies = {
  discount(price){
    return price * 0.7
  },
  coupon(price, coupon){
    return price - coupon
  },
  common(price){
  	return price
  }
}

// context 上下文, 为了给使用者调用算法
function settle(type,...args){
  return strategies[type].apply(this,args)
}

// 用户
settle('common',1000)
settle('coupon',1000,200)
settle('discount',1000)
```

## 代理模式

> 代理模式是一种结构型设计模式，它通过创建一个代理对象来控制对另一个对象的访问，为其他对象提供一种代理以控制对这个对象的访问。
>
> 代理模式通常涉及三个角色：
>
> 1. 抽象主题角色：定义了代理类和真实主题类的公共接口，这样在任何可以使用真实主题的地方都可以使用代理类。
> 2. 真实主题角色：定义了代理所表示的真实对象，在代理角色中被代理的对象。
> 3. 代理角色：代理角色内部含有对真实主题的引用，并且提供与真实主题角色相同的接口，代理角色可以在客户端和真实主题之间起到中介的作用。
>
> 代理模式有多种类型，常见的有远程代理、虚拟代理、保护代理和智能引用代理等。其中，远程代理用于在不同地址空间中代表对象，虚拟代理用于创建开销大的对象，保护代理用于控制对原始对象的访问，而智能引用代理则在访问对象时添加一些额外的操作。
>
> 代理模式可以带来许多好处，比如增加代码的可复用性、降低系统的耦合度、控制对对象的访问、提高系统的性能等。在实际应用中，代理模式经常用于构建安全、稳定和高效的系统。
>
> 
>
> 代理模式: 为一个对象提供一个替代对象. 替代对象称为代理对象, **代理对象应该持有原对象的引用**, 并且为了对用户使用透明, **应该向上抽取接口定义代理对象和原对象共同的调用接口**

> 生活场景: 小明想认识刘亦菲, 但是刘亦菲不是容易接触的, 小明需要通过刘亦菲的经纪人才能联系到刘亦菲. 这个经纪人就起到代理对象的作用. 
>
> 其中刘亦菲是元对象, 经纪人是代理对象.经纪人持有刘亦菲的引用(电话号码). 小明对象身上应该有个联系的方法, 刘亦菲和经纪人对象身上应该都有接受联系的方法. 这个方法应该被抽取到接口以约束他们



```js
const liuYiFei = {
  receive(){
    console.log('刘亦菲接受到联系')
  }
}
const proxyLiuYiFei = {
  lyf:liuYiFei
  receive(){
    this.lyf.receive()
  }
}

const xiaoMing = {
  contact(){
    proxyLiuYiFei.receive()
  }
}
```

在这个例子中,  为刘亦菲的对象建立了一个代理对象, 代理对象持有了刘亦菲的引用. 并且共同实现了receive方法, 在js中没有interface, 在后端语言中, 这个方法应该提到接口中强制约束, 好处是对于小明调用方法来说, 是透明的, 无差别的



### 保护代理

> 保护代理是有益于代理对象的, 虚拟代理是为了有益于客户的
>
> 保护代理是为了屏蔽一些操作, 比如小明追刘亦菲, 如果学历不高, 钱也少, 颜值也低,她大概率是不愿意的(无恶意). 那么代理对象姐可以在接受到联系请求的时候, 做一些判断, 如果不符合一定的要求, 选择拒绝. 这是保护代理
>
> 虚拟代理作为创建开销大的对象的代表，经常会直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理地来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。

### 虚拟代理

> 在真实开发中. 虚拟代理应用场景很多. 下面是几个例子

**图片懒加载**

```js
// 这个函数是创建和添加图片的函数, 但是在网络延迟情况下, 图片可能未即时加载
// 此时可以用代理模式
const createImg = (src, parent) => {
  const img = document.createElement('img')
  img.src = src
  parent.appendChild(img)
  return img
}

const proxyCreateImg = (src,parent) => {
  const img = createImg('file://本地占位图的url',parent) // 将图片显示未本地占位图
  
  const loadImg = new Imgage() // 新建一个image图像
  loadImg.src = src           // 将图像的src指向真正的链接, 下载图片
  loadImg.onload = function(){  // 当图片下载完成, 将真正img的src做切换
    img.src = this.src
  }
}

// 用户
proxyCreateImg('https://百度.png',document.body)
```

在这个例子里, 原对象为createImg函数, 代理对象为proxyCreateImg函数. 由于都是函数. 没有共同的接口, 这是由于js的便利性和后端语言的实现产生了差别. 其次, 代理对象proxyCreateImg函数内部中调用了createImg函数, 即代理对象持有原对象的引用

最后, 这是一个虚拟代理. 因为代理的目的是对客户有利的, 并且延缓了开销大的操作, 在这段时间内占位图充当了虚拟的原对象的角色.



### 缓存代理

> 缓存代理即代理的主要目的是缓存的需求

> 一个实际开发需求: 分页秒开的功能.
>
> 很多人都有阅读网文的习惯, 那就一定体会的到, 当点击下一页时候即使是1s的loading也让使用者痛苦, 当阅读到小说高潮时候的时候, 他点击下一页时候希望的是迅速的切到下一页, 多0.5s的延迟都会流失大量的客户.
>
> 下面是使用缓存代理模拟分页秒开需求

```js
// 一个请求某一页文章数据的方法, 一般后端会要求传页码和每页的数量大小
const getText = (page,pageSize) => {
  return axios({
    method:'get',
    url:'url地址',
    params:{ page,pageSize }
  })
}
// 代理对象应该和被代理者输出的接口相同, 所以也要返回promise
const proxyGetText = (() => {
  const cache = [] // 缓存的数组, 其中下标的含义是页码, value是缓存的数据
  return (page,pageSize) => {
    return async () => {
      // 如果本页和下一页都有数据, 直接返回本页数据
      if(cache[page] && cache[page + 1]) return cache[page]
   	  // 如果本页或者下一页没有数据, 请求完放在缓存中 
      if(!cache[page]){
         cache[page] = await getText(page), pageSize)
       }
      // 请求下一页数据应该是异步的, 因为同步的话第一次打开会是双倍的慢
      if(!cache[page + 1]){
         getText(page + 1, pageSize).then((res) => (cache[page + 1] = res) )
      }
      return cache[page]
    }
  }
})();

// 客户端伪代码. 比如react环境
function App {
  const [text,setText] = useState()
  const [page,setPage] = useState(1)
  
  const getText = () => {
    const res = await proxyGetText(page,10)
    setText(res)
  }
  
  useEffect(() => {
    getText()
  }, [page])
  return <>{text}<>
}

```

### 工厂代理

> 工厂代理是提供一个工厂产生代理对象. 工厂模式和代理模式的混合应用
>
> 上面的代码中, 主要的问题存在于
>
> 1. 代理对象采用了闭包的方式实现, 复杂且可读性差, 基于工厂模式的代理模式可能会清晰易读
> 2. 变量命名不规范, 可读性差
> 3. 采用数组做缓存, 如果是连续的页码还好, 但是如果是不连续的页码, 数组会出现"空洞", 并且数组的删除效率很低. 这里采用Map

```react
// 服务端接口
async function fetchArticles(pageNumber, pageSize) {
  const response = await axios.get('/api/articles', {
    params: {
      page: pageNumber,
      size: pageSize
    }
  });
  return response.data;
}

// 工厂模式返回代理对象
function createArticleProxy(fetcher) {
  const cache = new Map();

  return async function getArticles(pageNumber, pageSize) {
    if (cache.has(pageNumber) && cache.has(pageNumber + 1)) {
      return cache.get(pageNumber);
    }
	
    if(!cache.has(pageNumber)){
      const result = await fetcher(pageNumber, pageSize);
      cache.set(pageNumber, result);
     }

    // 异步请求下一页
    if (!cache.has(pageNumber + 1)) {
      fetcher(pageNumber + 1, pageSize).then((res) => {
        cache.set(pageNumber + 1, res);
      });
    }

    return result;
  }
}

// 客户端代码
import React, { useState, useEffect } from 'react';

function ArticleList() {
  const [articles, setArticles] = useState([]);
  const [pageNumber, setPageNumber] = useState(1);

  const getArticles = createArticleProxy(fetchArticles);

  useEffect(() => {
    async function fetchArticlesAsync() {
      const result = await getArticles(pageNumber, 10);
      setArticles(result);
    }
    fetchArticlesAsync();
  }, [pageNumber]);

  return (
    <div>
      {articles.map(article => (
        <div key={article.id}>
          <h2>{article.title}</h2>
          <p>{article.content}</p>
        </div>
      ))}
      <button onClick={() => setPageNumber(prevPageNumber => prevPageNumber + 1)}>Load More</button>
    </div>
  );
}
```

## 迭代器模式

> 迭代器模式是一种行为设计模式，它允许你在不暴露集合底层表现形式（如列表、栈和树等）的情况下访问集合中的元素。
>
> 在迭代器模式中，集合对象提供一个访问它的元素的接口，而客户端代码则使用这个接口来遍历集合中的元素，而不需要了解集合底层的数据结构。这样做的好处是，可以随时改变集合底层的数据结构，而不需要改变客户端代码。
>
> 迭代器模式包含两个核心组件：
>
> 1. 迭代器(Iterator)：定义了遍历集合元素的接口。
> 2. 集合对象(Aggregate)：定义了创建迭代器的接口，同时提供了遍历集合元素的方法。
>
> 迭代器模式的优点包括：
>
> 1. 隐藏了集合的具体实现，使得代码更加灵活和可维护。
> 2. 提供了一种遍历集合元素的标准方法，使得客户端代码更加简洁和易读。
> 3. 支持多种遍历方式，如正序遍历、倒序遍历、跳跃遍历等。
>
> 迭代器模式的缺点包括：
>
> 1. 增加了代码的复杂度，需要定义迭代器接口和实现类。
> 2. 对于简单的集合结构，使用迭代器模式可能会显得过于繁琐。
>
> 在 JavaScript 中，迭代器模式通常与 ES6 中的迭代器协议和生成器函数一起使用，这样可以更方便地遍历数组、集合等数据结构。

> 大部分语言已经实现了迭代器模式, 比如ES6 的forEach,same,map..等方法, 不用手写实现



## 观察者模式

> 观察者模式是一种一对多的依赖关系设计模式, 使得当一个对象状态改变时，所有依赖它的对象都能够自动得到通知并且更新. 
>
> 其需有Subject主题类,  观察者Observer类, 其中Subject主题类为被观察的对象.
>
> Subject应该有以下类似属性: observers: 报错所有的观察者. items: 保存变化的数据结构. 以及若干方法: 对observers和items增删改查的方法. notify: 用于刷新observers, 通知每一个观察者改变了的方法
>
> 每一个Observer应该具有共同的接口用于接收变化.

###Typescript实现购物车案例的观察者模式

> 下面是一个购物车的观察者模式的例子. 

```typescript
// 观察者应该具有收到变化的相同的更新接口
interface Good { 
  key: number | string | symbol
  price: number
}

interface Observer { 
  update(goods:Good[]):void
}

// Subject类, 被观察的对象类
class Shopcar { 
  goods: Good[] // 商品
  observers: Observer[] //观察者们
  
  addGood(good:Good) { 
    this.goods.push(good)
    this.notify(this.goods)
  }

  removeGood(good: Good) {
    this.goods = this.goods.filter(item => item.key !== good.key) 
    this.notify(this.goods)
  }

  addObserver(ob: Observer) {
    this.observers.push(ob)
  }
  
  notify(goods:Good[]) {
    this.observers.forEach(ob => ob.update(goods))
   }
}

// 记录商品总价的组件, 当购物车中的商品变化的时候自动更新总价
class CartTotal implements Observer { 
  price: number = 0
  
  update(goods: Good[]): void {
    this.price = goods.reduce((pre, curr) => pre + curr.price,0)
  }

  render() { 
    return this.price
  }
}

// 记录商品总数的组件, 当购物车中的商品变化的时候自动更新总价
class CartCount implements Observer { 
  count: number = 0
  
  update(goods: Good[]): void {
    this.count = goods.length
  }

  render() { 
    return this.count
  }
}
```

### 使用React重构购物车案例

> 上面使用ts实现的观察者模式案例, 但是由于开发的灵活性, 我们不必严格按照定义的那样定义观察者
>
> 下面是一个React重构购物车案例的例子, 也是用的观察者模式



ShopcartContext.js

```react
import {createContext,useState,useContext} from 'react'

const ShopcartContext = createContext({})

const ShopcartProvider = ({children}) => {
  const [goods,setGoods] = useState([])
  const addGoods = (good) => setGoods(pre => [...pre,good])
  const removeGoods = (id) => setGoods(pre => pre.filter(item.id !== id))
  
  return (
    <ShopcartContext.Provider value={[goods,addGoods,removeGoods]}> 
      { children } 
    </ShopcartContext.Provider>
  )
}

const useShopcart = () => {
  const context = useContext(ShopcartContext)
  return context
}

```

总数组件

```js
import { useShopcart } from './ShopcartContext';

function CartCount() {
  const [goods] = useShopcart();

  const count = goods.length;

  return <div>Count: {count}</div>;
}

export default CartCount;
```

总价组件

```js
import { useShopcart } from './ShopcartContext';

function CartTotal() {
  const [goods] = useShopcart();

  const total = goods.reduce((sum, item) => sum + item.price, 0);

  return <div>Total: ${total.toFixed(2)}</div>;
}

export default CartTotal;
```

在这个例子中, Subject主题, 即被观察的对象为ShopcartContext对象, 当上下文对象变化的时候, 依赖于它的总价和总数组件都会更新.

Observers为总价和总数组件.

和上面的ts实现区别是, Subject并没有显式的实现的notify方法,Observer也没有显式的接口update, 这是依赖于react实现的"当Context刷新时候, 所有组件自动渲染." 并且需要注意的是Context.Provider持有了所有Observer的引用, 这是和发布订阅模式的重要区别.

## 命令模式

> 命令模式是一种行为型设计模式，它将一个请求封装成一个对象，从而使你可以使用不同的请求、队列或者日志来参数化其他对象。命令模式可以让请求的发送者和接收者彻底解耦，发送者不需要知道请求的具体执行过程，只需要知道如何发送命令和命令对象的接口。
>
> 命令模式通常由四个部分组成：命令对象、接收者对象、调用者对象和客户端对象。命令对象封装了请求的操作和参数，接收者对象负责实际执行命令的操作，调用者对象将命令对象传递给接收者对象，并负责调用命令对象的方法，客户端对象创建命令对象并设置命令对象的接收者对象和参数。
>
> 命令模式可以使代码更加灵活，可以动态地添加新的命令，也可以将命令对象序列化到磁盘上，从而实现撤销和恢复操作。它还可以将多个命令组合成一个复合命令，从而实现批处理操作。命令模式在很多应用中都有广泛的应用，例如图形界面的菜单、工具条和快捷键操作等。
>
> 
>
> 命令模式的作用在于 命令的发出者和接受者之间的解耦合. 命令的发出者不知道接受者是谁, 也不知道接受者是如何实现功能的, 命令的接受者不知道谁发出的命令, 何时会发出命令. 双方都面向命令编程
>
> 在命令模式中, 命令类持有接受者的引用

### 命令模式实现文本编辑器

```typescript
// 命令的接口. 最基本的命令应该包含以下几点 1. 共同的触发方法 2. 撤销方法 3. 接受者的引用
// 此外命令对象会存储该命令操作的相关数据, 用于undo. 这些需要在创建命令时候传进来
interface Command<R> { 
  receiver:R
  execute(): void
  undo(): void
}

// 编辑器组件, 提供插入文本,  删除文本,撤销和重做操作,
class Editer { 
  text: string = ''
  commands: Command<Editer>[] = []
  
  insertText(position: number, text: string) {
    this.text = this.text.slice(0, position) + text + this.text.slice(position)
    this.commands.push(new InsertTextCommand(this,text,position))
  }

  deleteText(position: number, length: number) { 
    const deleteText = this.text.slice(position, position + length)
    this.text = this.text.slice(0, position) + this.text.slice(position + length)
    this.commands.push(new DeleteTextCommand(this,deleteText,position))
  }
  
  // 编辑器的重做, 由于不知道上一步是什么. 所以需要调出历史记录栈, 依靠命令来重做
  undo() { 
    const command = this.commands.pop()
    if (command) {
      command.undo()
    }
  }
  
  redo(step?: number) {
    if (!step) {
      while (this.commands.length > 0) {
        this.commands.pop()?.undo()
      }
      return
    }
    
    while (step > 0) {
      this.commands.pop()?.undo()
      step--
     }
   }
}

// 插入文本命令
class InsertTextCommand<R> implements Command<R> { 
  receiver: R
  insertText:string = ''
  position: number

  constructor(receiver: R, text:string, position:number) { 
    this.receiver = receiver
    this.insertText = text
    this.position = position
  }

  execute(): void {
    if (this.receiver instanceof Editer) {
      this.receiver.insertText(this.position,this.insertText)
     }
  }

  undo(): void {
    if (this.receiver instanceof Editer) {
      this.receiver.deleteText(this.position, this.insertText.length) 
     }
  }
}
      
// 删除文本的命令
class DeleteTextCommand<R> implements Command<R> { 
  receiver: R
  deleteText: string = ''
  position: number

  constructor(receiver: R,deleteText:string,postion:number) { 
    this.receiver = receiver
    this.deleteText = deleteText
    this.position = postion
  }
  execute(): void {
    if (this.receiver instanceof Editer) {
      this.receiver.deleteText(this.position,this.deleteText.length)
     }
  }
  undo(): void {
    if (this.receiver instanceof Editer) {
      this.receiver.insertText(this.position,this.deleteText)
     }
  }
}
// 测试插入文本
const editor = new Editer()
editor.insertText(0, 'hello')
console.log(editor.text) // expect: hello
editor.insertText(3, ' world')
console.log(editor.text) // expect: hel worldlo

// 测试删除文本
editor.deleteText(3, 5)
console.log(editor.text) // expect: hello

// 测试撤销
editor.undo()
console.log(editor.text) // expect: hel worldlo

// 测试重做
editor.redo(2)
console.log(editor.text) // expect: hello
```





## 组合模式

> 组合模式是一种设计模式，它允许你将对象组合成树形结构，以表示“部分-整体”的层次结构。组合模式使得客户端可以以统一的方式处理单个对象以及对象组合，因此在处理对象时可以忽略对象组合与单个对象之间的差异。
>
> 在组合模式中，有两种类型的对象：叶子对象和组合对象。叶子对象是不可再分的基本对象，而组合对象是由多个叶子对象或组合对象组成的树形结构。组合对象可以递归地包含更多的组合对象和叶子对象。
>
> 通过使用组合模式，你可以将对象组织成树形结构，使得客户端可以统一处理单个对象和对象组合。这样，你可以将某些行为委托给树中的对象，从而简化了客户端代码，并且可以在不改变客户端代码的情况下添加新的对象或组合对象。
>
> 
>
> 总结: 
>
> 组合模式是应用与一下场景. 将对象维护成树形结构, 并且在操作树形结构时候, 能够以统一的方式操作叶子节点和非叶子节点. 也就是说, 对于使用者来说, 操作叶子节点和非叶子节点是相同, 至于内部代码是怎么回事, 不需要关系.
>
> 这就需要 1. 组合对象拥有维护叶子节点的数据结构 2. 组合对象和叶子节点具有相同的接口, 使用者根据接口屏蔽两个对象的差异



###组合模式实现导航菜单栏

> 对于菜单栏需求来说, 叶子节点是每个菜单项. 整个菜单栏的数据结构一定是树形的, 针对这样的场景, 可以考虑用组合模式
>
> 为菜单项提供一个组合对象, 即子菜单栏, 他维护了叶子节点们, 并且跟叶子节点具有相同的接口



```typescript
interface MenuItem {
  name: string;
  url: string;
  children?: MenuItem[];
}

class Menu implements MenuItem {
  name: string;
  url: string;
  children: MenuItem[];

  constructor(name: string, url: string, children: MenuItem[] = []) {
    this.name = name;
    this.url = url;
    this.children = children;
  }

  add(menuItem: MenuItem): void {
    this.children.push(menuItem);
  }

  remove(menuItem: MenuItem): void {
    const index = this.children.indexOf(menuItem);
    if (index > -1) {
      this.children.splice(index, 1);
    }
  }
}

// 创建菜单项
const home = new Menu("Home", "/");
const about = new Menu("About", "/about");
const products = new Menu("Products", "/products");
const services = new Menu("Services", "/services");

// 创建子菜单项
const webDesign = new Menu("Web Design", "/services/web-design");
const webDevelopment = new Menu("Web Development", "/services/web-development");
const seo = new Menu("SEO", "/services/seo");

// 将子菜单项添加到 Services 菜单项中
services.add(webDesign);
services.add(webDevelopment);
services.add(seo);

// 将所有菜单项添加到主菜单中
const mainMenu = new Menu("Main Menu", "/");
mainMenu.add(home);
mainMenu.add(about);
mainMenu.add(products);
mainMenu.add(services);

// 打印输出菜单
console.log(mainMenu);
```

 

### React重构菜单导航栏

> 在这个示例中，我们使用了 React 函数式组件来实现菜单栏。`Menu` 组件和 `MenuItem` 组件分别对应组合模式中的组合对象和叶子对象，它们的实现类似于之前的类实现版本。
>
> `Menu` 组件接受一个菜单项数组 `menu` 作为属性，遍历 `menu` 数组，并为每个菜单项渲染一个 `MenuItem` 组件。`MenuItem` 组件接受一个菜单项对象 `item` 作为属性，并根据菜单项是否包含子菜单项来决定渲染方式。
>
> 如果菜单项包含子菜单项，则渲染一个带有子菜单项的列表项，其中包含一个链接和一个 `Menu` 组件，用于渲染子菜单项。如果菜单项不包含子菜单项，则只渲染一个链接的列表项。由于 `MenuItem` 组件本身是递归嵌套的，因此可以无限层级地渲染嵌套菜单。
>
> 通过这种方式实现，客户端可以以相同的方式处理菜单项和包含子菜单项的菜单对象，而不需要在处理它们时进行特殊的区分，这符合组合模式的设计思想。

```typescript
interface MenuItem {
  name: string;
  url?: string;
  children?: MenuItem[];
}

interface MenuProps {
  menu: MenuItem[];
}

function Menu({ menu }: MenuProps) {
  return (
    <ul>
      {menu.map((item) => (
        <MenuItem key={item.name} item={item} />
      ))}
    </ul>
  );
}

interface MenuItemProps {
  item: MenuItem;
}

function MenuItem({ item }: MenuItemProps) {
  const hasChildren = item.children && item.children.length > 0;

  if (hasChildren) {
    return (
      <li>
        <a href={item.url}>{item.name}</a>
        <Menu menu={item.children} />
      </li>
    );
  }

  return (
    <li>
      <a href={item.url}>{item.name}</a>
    </li>
  );
}
```



总结 

在之前的版本中，`Menu` 类既可以作为组合对象，又可以作为叶子对象，这并不符合组合模式的设计思想。组合模式的目标是使客户端可以以统一的方式处理单个对象和对象组合，因此组合对象和叶子对象应该有清晰的区分。在之前的版本中，`Menu` 类即有组合对象的特点（包含子菜单项），也有叶子对象的特点（没有子菜单项时直接渲染菜单项），这就使得客户端在处理 `Menu` 对象时需要根据其是否包含子菜单项进行特殊的区分，不符合组合模式的设计思想。

React 版本中，`Menu` 组件作为组合对象，只包含菜单项数组 `menu`，而不包含子菜单项。`MenuItem` 组件作为叶子对象，根据菜单项是否包含子菜单项来决定渲染方式。这样设计符合组合模式的思想，使得客户端在处理菜单时可以以统一的方式处理单个菜单项和包含子菜单项的菜单对象。

需要注意的是，组合模式并不要求组合对象和叶子对象必须是不同的类或接口，可以根据实际情况灵活设计。重点在于通过组合模式，让客户端可以以统一的方式处理单个对象和对象组合，从而降低系统复杂性。





## 模板方法模式  

模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个操作中的算法骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤。

在模板方法模式中，将算法的骨架定义在抽象类中，而具体实现则交由子类来完成。抽象类中的模板方法会调用多个抽象方法和具体方法，这些方法可以在子类中被重写或者直接继承。通过这种方式，模板方法模式可以让子类在不改变算法结构的情况下，根据需要重新定义算法的具体步骤。

模板方法模式常用于多个类中有相同的算法，但是其中某些步骤的实现方式可能不同的情况下。通过将相同的算法封装在抽象类中，可以避免代码重复，并且让子类可以根据需要实现不同的步骤，从而实现代码的重用和灵活性。



**总结: 将共同的方法抽取到抽象类中. 抽象类中定义了方法的调用顺序.**



### 模板方法模式实现TodoList

todoList可以显示"已完成", "未完成", "所有"的待办事项.

思考一下, 这三个行为都是执行相同的算法流程

1. 获取原始todo数据
2. 筛选出已完成/未完成/或者不筛选数据
3. 渲染到页面上

所以针对这种, 多个行为具有相同的算法流程的, 可以使用模板方法模式

```typescript
interface Todo {
  key: string
  name: string
  isDone:boolean
}


// 封装了一些方法, 有些是实现和未实现的. 以及对方法的调用顺序
abstract class DisplayTodo { 
  getTodos(): Todo[] { 
    const todos = localStorage.getItem('todo-list')
    if (!todos) return []

    try {
      return JSON.parse(todos)
    } catch (error) {
      return []
    }
  }

  abstract filterTodo(todos:Todo[]): Todo[]

  abstract render(todos:Todo[]): string 
  
  // 模板方法. 封装了算法的调用流程
  display(): void { 
    const todos = this.getTodos()
    const htmlString = this.render(todos)
    const div = document.createElement('div')
    div.innerHTML = `<div>${htmlString}</div>`
    document.body.appendChild(div)
  }
}

class AllTodoDisplay extends DisplayTodo {
  filterTodo(todos:Todo[]): Todo[] {
    return todos
  }
  render(todos: Todo[]): string {
    // 这里可以实现, 你想让全部怎么渲染..不再写代码
  } 
  
}

class DoneTodoDisplay extends DisplayTodo {
  filterTodo(todos: Todo[]): Todo[] {
    return todos.filter(todo => todo.isDone)
  }
  render(todos: Todo[]): string {
    // 这里可以实现, 你想让未完成怎么渲染..不再写代码
  } 
  
}

class NotDoneTodoDisplay extends DisplayTodo {
  filterTodo(todos: Todo[]): Todo[] {
    return todos.filter(todo => !todo.isDone)
  }
  render(todos: Todo[]): string {
    // 这里可以实现, 你想让未完成怎么渲染..不再写代码
  } 
  
}


// 使用时候.
// 当点击"未完成"的按钮时候
new NotDoneTodoDisplay().display()
// 当点击"完成"按钮的时候
new DoneTodoDisplay().display()
// 当点击"所有"按钮的时候
new AllTodoDisplay().display()
```



这段代码使用了模板方法模式来封装一个显示 todo list 的逻辑，其中 `DisplayTodo` 是一个抽象类，实现了 `getTodos` 方法来从本地存储获取 todo list，同时声明了抽象方法 `filterTodo` 和 `render`，需要具体的子类来实现。

具体的子类 `AllTodoDisplay`，`DoneTodoDisplay`，`NotDoneTodoDisplay` 分别实现了 `filterTodo` 和 `render` 方法，来达到不同的显示效果。

在 `DisplayTodo` 抽象类中定义了一个 `display` 方法，使用了模板方法模式，将获取数据、过滤和渲染的具体实现封装在了一个方法中，并规定了调用流程，具体实现交由子类完成。

最后，通过实例化具体的子类对象，调用 `display` 方法来展示不同的 todo list 显示效果。



### 使用React和模板方法模式重构

```jsx
import React, { useState } from 'react';

interface Todo {
  key: string;
  name: string;
  isDone: boolean;
}

interface DisplayTodoProps {
  todos: Todo[];
  filterTodo():Todo[];
  render():string;
}

// 封装了一些方法, 有些是实现和未实现的. 以及对方法的调用顺序
function DisplayTodo(props: DisplayTodoProps) {
  const { todos,filterTodo,render } = props;

  // 模板方法. 封装了算法的调用流程
  function display() {
    const filteredTodos = filterTodo();
    const html = render(filteredTodos);
    return <div>{html}</div>;
  }

  return display();
}

function AllTodoDisplay(props: DisplayTodoProps) {
  function filterTodo(): Todo[] {
    return props.todos;
  }

  function render(todos: Todo[]): React.ReactNode {
    // 这里可以实现, 你想让全部怎么渲染..不再写代码
    return null;
  }

  return <DisplayTodo todos={props.todos} filterTodo={filterTodo} render={render} />;
}

function DoneTodoDisplay(props: DisplayTodoProps) {
  function filterTodo(): Todo[] {
    return props.todos.filter(todo => todo.isDone);
  }

  function render(todos: Todo[]): React.ReactNode {
    // 这里可以实现, 你想让完成的怎么渲染..不再写代码
    return null;
  }

  return <DisplayTodo todos={props.todos} filterTodo={filterTodo} render={render} />;
}

function NotDoneTodoDisplay(props: DisplayTodoProps) {
  function filterTodo(): Todo[] {
    return props.todos.filter(todo => !todo.isDone);
  }

  function render(todos: Todo[]): React.ReactNode {
    // 这里可以实现, 你想让未完成的怎么渲染..不再写代码
    return null;
  }

  return <DisplayTodo todos={props.todos} filterTodo={filterTodo} render={render} />;
}

// 使用时候.
// 当点击"未完成"的按钮时候
const [todos, setTodos] = useState<Todo[]>([]);
return <NotDoneTodoDisplay todos={todos} />;
// 当点击"完成"按钮的时候
return <DoneTodoDisplay todos={todos} />;
// 当点击"所有"按钮的时候
return <AllTodoDisplay todos={todos} />;

```

在重构后的代码中，`DisplayTodo` 组件接收 `todos` 作为 props，通过函数来实现 `filterTodo` 和 `render` 方法。在 `display` 方法中，调用 `filterTodo` 和 `render` 方法来得到要渲染的内容，并将其展示在页面上。

具体的子组件 `AllTodoDisplay`、`DoneTodoDisplay` 和 `NotDoneTodoDisplay` 分别实现了 `filterTodo` 和 `render` 方法，并通过传递这些方法来调用 `DisplayTodo` 组件进行展示。

在使用时，只需要将 `todos` 作为 props 传递给相应的子组件，就可以渲染出相应的 todo list



## 享元模式

> 享元模式（Flyweight Pattern）是一种结构型设计模式，它通过共享已经存在的对象来减少创建新对象的数量，从而节省内存和提高性能。
>
> 在享元模式中，对象通常被分为两类：内部状态和外部状态。内部状态是对象可以共享的状态，它通常存储在享元对象内部，并且不随环境的变化而改变。外部状态则是对象依赖于环境的状态，它不可以共享，通常由客户端在运行时动态传递给享元对象。
>
> 通过共享内部状态和分离外部状态，享元模式可以大幅度减少对象的数量，从而降低内存的消耗和系统的负担，提高程序的运行效率和性能。
>
> 享元模式通常适用于以下场景：
>
> - 当系统中存在大量的相似对象需要创建时，可以使用享元模式来减少对象的数量。
> - 当创建对象的代价较高，而且多个对象之间可以共享同一状态时，可以使用享元模式来降低系统的开销。
> - 当需要对对象进行缓存，以提高系统性能和响应速度时，也可以使用享元模式来实现对象的复用和共享。



> 总结 :
>
> 享元模式应该具备两点 1. 根据内部状态缓存对象的工厂 2. 根据外部状态动态添加的状态机
>
> 内部状态指的是, 我们可以根据内部状态将一堆对象分成若干组的属性, 是共享的属性
>
> 外部状态是后期添加的属性, 是每个对象间可能不一样的属性的集合



### 享元模式实现文件上传

```js
// 上传类, 可以选择上传方式
class Upload { 
  uploadType: string // 内部状态
  file:Blob // 外部状态动态添加
  constructor(type: string) {
    this.uploadType = type
  }

  execute(id:string | number,url:string): Promise<any> {
    return new Promise((resolve) => { 
      UploadManager.mergeExternalState(id, this)
      const fm = new FormData()
      fm.append('file',this.file)
      fetch(url, {
        body: fm
      }).then(resolve)
    })
  }

}

// 缓存Upload对象
const UploadFactory = (() => { 
  const cache = new Map<string,Upload>()
  return {
    create(type:string) { 
      if (cache.has(type)) {
        return cache.get(type)!
      }
      const upload = new Upload(type)
      cache.set(type,upload)
      return upload
    }
  }
})();

// 状态机, 动态添加外部状态
// 具有 1. 缓存具体Upload的外部状态 2. 合并外部状态 3. 获取Upload对象的功能
// 这里其实可以不用缓存外部状态...看实际需求把
const UploadManager = (() => { 
  // 缓存外部状态
  const externalStateDB = new Map<any,any>()
  
  return {
    getUpload(id:string | number, type:string, file:Blob): Upload { 
      const upload = UploadFactory.create(type)
      // 缓存外部状态
      externalStateDB.set(id, {
        file
      })
      
      return upload
    },
  
    mergeExternalState(id:string, upload: Upload) { 
      const externalState = externalStateDB.get(id)
      for (let k in externalState) {
        upload[k] = externalState[k]
      }
    }
  }
})();

// 测试
let id = 0
for (let i = 0; i < 100; i++) {
  const upload = UploadManager.getUpload(id++ + '', '插件', new File([], 'ss.text'))
  upload.execute(id,'http://baidu.com')
}

```

这个例子它展示了享元模式的基本思想和实现方式。在这个示例中，Upload 类是享元对象，uploadType 属性是内部状态，file 属性是外部状态，外部状态可以在执行 execute 方法时动态添加。通过 UploadFactory 工厂类和 UploadManager 状态机类，可以实现 Upload 对象的缓存和外部状态的合并，从而减少了重复创建对象和减少了内存占用。

需要注意的是，这个示例仅仅是为了说明享元模式的思想和实现方式，并不一定适用于所有场景。在实际应用中，需要根据具体的业务需求和性能要求来选择是否使用享元模式。



## 职责链模式

> 职责链模式（Chain of Responsibility pattern）是一种行为设计模式，它允许将请求沿着一个处理链进行传递，直到其中一个处理程序能够处理它为止。
>
> 在职责链模式中，多个处理器（也称为处理者）被链接在一起。当一个请求被发出时，它沿着这个链传递，直到有一个处理器能够处理它。每个处理器都有一个处理级别和一个处理策略，如果它不能处理请求，则会将请求转发给链中的下一个处理器，直到找到能够处理请求的处理器为止。
>
> 职责链模式的好处是它可以灵活地扩展和修改处理链，而不影响代码的其余部分。此外，它还可以帮助将复杂的代码逻辑分解为较小的处理单元，使代码更易于维护和测试。

> 实际实现的时候, 一般需要职责链节点向上抽取接口, 规定共同的接口, 方便迭代

> 职责链模式在前端十分常见: 比如axios的拦截器: 将所有请求和响应拦截器存在数组里, 形成顺序数组, 在得到请求配置/响应时候遍历顺序表, 得到最终config或者response
>
> 比如各种第三方库的插件系统: webpack的plugins, vuex的plugins等

### 职责链模式实现ajax请求中间件

```typescript
interface Request { 
  url:string
  headers?: Record<string, string>
  body?: string | object
  method:string
}

interface Response { 
  headers: Record<string, string>
  body?: string
  status: number
}
// 请求插件的抽象类
// 规定了每个中间件都需要维护下个节点的索引
// 必须实现插件的调用方法
// 提供了调用下个插件的方法(迭代职责链的方法)
abstract class RequestMiddleWare { 
  next: RequestMiddleWare | null = null
  
  constructor(next?: RequestMiddleWare) { 
    if (next) {
      this.next = next
    }
  }

  abstract handle(request:Request): Promise<Response> 

  async handleNextMiddleWare(request:Request): Promise<Response> { 
    if (this.next) { 
      return await this.next.handle(request)
    }
    throw new Error("没有下一个中间件");
  }
}
// 添加token的插件
class TokenMiddleWare extends RequestMiddleWare {
  token: string

  constructor(next:RequestMiddleWare,token:string) { 
    super(next)
    this.token = token
  }

  async handle(request: Request): Promise<Response> {
    if (!request.headers) {
      request.headers = {}
    }

    request.headers['Autorization'] = `Bearer ${this.token}`
    return await this.handleNextMiddleWare(request)

  } 
}
// 将Bofy序列化的插件
class JSONBodyMiddleware  extends RequestMiddleWare {
  async handle(request: Request): Promise<Response> {
    if (request.body && request.headers) {
      request.headers['Content-Type'] = 'application/json'
      request.body = JSON.stringify(request.body)
    }

    return await this.handleNextMiddleWare(request)
  }
}
// 真正发送请求的方法
class HttpMiddleWare extends RequestMiddleWare {
  async handle(request: Request): Promise<Response> {

    const response = await fetch(request.url, {
      headers: request.headers,
      body: JSON.stringify(request.body),
      method: request.method
    })

    return { 
      headers: this.mapHeaders(response.headers),
      body: await response.json(),
      status: response.status
    }
    
  }
  
  mapHeaders(headers: Headers): Record<string,string> { 
    const h:Record<string,string> = {}
    for (const [key,value] of headers) {
      h[key] = value
    }
    return h
  }
  
}


// 测试代码
const request: Request = {
  url: "http://www.baidu.com",
  method: "get",
  body: {
    hobby:['吃饭','睡觉']
  }
}

// 合成职责链
const chain = new TokenMiddleWare(new JSONBodyMiddleware(new HttpMiddleWare()), 'token')
// 将请求传递到职责链每一个地方处理
chain.handle(request)
```

## 中介者模式

> 中介者模式(Mediator Pattern）又称为调解者模式或调停者模式。用一个中介对象封装一 系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立 地改变它们之间的交互。属于行为型模式。

> 中介模式避免了复杂的依赖关系. 所有的对象在改变自身的时候通知中介者, 由中介者封装运算逻辑, 并将逻辑通知到依赖关系的第三方

```js

interface IPlane { 
  airline: string
  id: string
  tower:Tower
  receiveMessage(message: string): void
  sendMessage(meesage:string):void
}

class Plane implements IPlane {
  airline: string
  id: string
  tower = new Tower()

  constructor(airline: string, id: string) { 
    this.airline = airline
    this.id = id
  }
  sendMessage(meesage: string): void {
    this.tower.receiveMessage(this,meesage)
  }

  receiveMessage(message: string): void {
    console.log(message)
  } 

}

// 灯塔: 中介者
class Tower {
  static tower = new Tower()

  constructor() {
    return Tower.tower
  }
  
  receiveMessage(plane:Plane,message:string) { 
    if (message === '降落') {
      // 1. 判断当前机场是否有空位
      // 2. 若有空位..
      // 3. 若无空位....
      // 4. 通知飞机结果
      this.sendMessage(plane, '可以降落/不可以降落/其他...')
     }
  }

  sendMessage(plane: Plane, meesage: string) {
    plane.receiveMessage(meesage)
   }
}
```

## 装饰者模式

> 装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许向一个对象动态地添加新的行为。它是通过将对象包装在一个装饰器类的实例中来实现的。这个装饰器类具有与被包装的对象相同的接口，因此可以无缝地替换原始对象。
>
> 装饰器模式的目的是在不改变现有对象接口的情况下，动态地向对象添加功能。这使得装饰器模式与继承相比具有更大的灵活性，因为继承会将新功能硬编码到对象中，而装饰器模式则允许在运行时动态地添加新功能。
>
> 装饰器模式通常使用组合而非继承来扩展对象的功能，这使得它更加灵活和易于扩展。同时，装饰器模式还遵循了开放封闭原则，即对扩展开放，对修改封闭。这意味着可以通过添加新的装饰器类来扩展对象的功能，而无需修改现有代码。

### 使用装饰者模式实现前端性能监控

```js
interface Monitor {
  upload(time?: number): void
  measure(name?: string, startMark?: string, endMark?: string): void
}

class BasePageLoadedMonitor implements Monitor {
  metrics: Record<string, PerformanceEntry> = {}

  // 获得某个entry
  measure(name: string, startMark?: string, endMark?: string): void {
    const entry = performance.getEntriesByName(name)[0]
    if (!entry) {
      performance.measure(name, startMark, endMark)
    } else {
      this.metrics[name] = entry
    }
  }

  // 上传检测日志
  upload(time?: number): void {
    if (time) {
      setTimeout(() => console.log(this.metrics), time)
    } else {
      console.log(this.metrics)
    }
  }
}

abstract class BasePageLoadedDecorator implements Monitor {
  monitor: Monitor

  constructor(monitor: Monitor) {
    this.monitor = monitor
  }

  measure(name: string, startMark?: string, endMark?: string): void {
    this.monitor.measure(name, startMark, endMark)
  }

  upload(time?: number): void {
    this.monitor.upload(time)
  }
}

class FCPDecorator extends BasePageLoadedDecorator {
  measure(): void {
    const name = 'first-contentful-paint'
    const entry = performance.getEntriesByName(name)[0]

    if (entry) {
      super.measure(name)
    } else if (window.PerformanceObserver) {
      const ob = new PerformanceObserver(() => {
        super.measure(name)
        ob.disconnect()
      })

      ob.observe({ type: name, buffered: true })
    }
  }
}

class LoadedDecorator extends BasePageLoadedDecorator {
  constructor(monitor: Monitor) {
    super(monitor)
    window.addEventListener('load', () => {
      this.loadedEvent()
    })
  }

  loadedEvent(): void {
    const name = 'loaded'
    performance.mark(name)
    super.measure(name, undefined, name)
  }
}

class DOMContentLoadedDecorator extends BasePageLoadedDecorator {
  constructor(monitor: Monitor) {
    super(monitor)
    window.addEventListener('DOMContentLoaded', () => {
      this.loadedEvent()
    })
  }

  loadedEvent(): void {
    const name = 'dom-content-loaded'
    performance.mark(name)
    super.measure(name, undefined, name)
  }
}

// 初始化
interface DecoratorConstructor {
  new (monitor: Monitor): Monitor
}

const createMonitor = (decorators: DecoratorConstructor[]): Monitor => {
  const baseMonitor = new BasePageLoadedMonitor()
  return decorators.reduce<Monitor>(
    (monitor, Decorator) => new Decorator(monitor),
    baseMonitor
  )
}

const monitor = createMonitor([
  FCPDecorator,
  LoadedDecorator,
  DOMContentLoadedDecorator
])
export default monitor

```

## 工厂模式

> 工厂模式是一种创建对象的设计模式，它提供了一种通过调用工厂方法来创建对象的方式，而不是直接使用 new 操作符。工厂方法是一个负责创建其他对象的方法，它通常被定义在一个接口或抽象类中，并由具体工厂类实现。

### 简单工厂模式

> 简单工厂模式是最简单的工厂模式, 客户端只需要知道工厂类, 不需要知道原对象. **一个工厂类可以创建不同的产品对象**

> 例子: 比如说动态的创建图表, 你可以决定想创建柱状图还是饼状图还是雷达图

```typescript
interface Chart { 
  render():void
}

// 柱状图
class BarChart implements Chart {
  render(): void {
    console.log('渲染柱状图');
  }
}

// 饼状图
class PieChart implements Chart {
  render(): void {
    console.log('渲染饼状图');
  }
}

// 雷达图
class RadarChart implements Chart {
  render(): void {
    console.log("渲染雷达图")
  }
}

// 图表工厂
type ChartType = "radar" | "pie" | "bar"
class ChartFactory  { 
  create(type:ChartType):Chart { 
    switch (type) {
      case "radar":
        return new RadarChart()
      case "pie":
        return new PieChart()
      case "bar":
        return new BarChart()
      default:
        throw new Error('请传入正确的表格信息')
    }
  }
}

// 客户端
new ChartFactory().create("pie")
```

### 工厂方法模式

> 简单工厂模式的优点是写法简单, 可以满足绝大部分需求. 
>
> 但也有缺点
>
> 简单工厂的定义是 "一个工厂可以创建不同的产品对象". 当新增一个产品类时候, 假如我们想通过工厂创建这个对象. 则需要修改原工厂的实现, 违反了开闭原则. 而且一个工厂负责了多个不同对象的创建, 颗粒度也不够细.
>
> 工厂方法模式要求 "一个工厂对应一个产品", 为了保证多个工厂的相同特性, 需要向上抽取为一个接口(约定工厂方法). 从而解决上述问题



> 将之前的例子改为工厂方法模式

```typescript
// 抽象产品类
interface Chart {
  render(): void;
}

// 具体产品类
class BarChart implements Chart {
  render(): void {
    console.log('渲染柱状图');
  }
}

class PieChart implements Chart {
  render(): void {
    console.log('渲染饼状图');
  }
}

class RadarChart implements Chart {
  render(): void {
    console.log('渲染雷达图');
  }
}

// 工厂接口
interface ChartFactory {
  createChart(): Chart;
}

// 具体工厂类
class BarChartFactory implements ChartFactory {
  createChart(): Chart {
    return new BarChart();
  }
}

class PieChartFactory implements ChartFactory {
  createChart(): Chart {
    return new PieChart();
  }
}

class RadarChartFactory implements ChartFactory {
  createChart(): Chart {
    return new RadarChart();
  }
}

// 客户端
const barChartFactory = new BarChartFactory();
const pieChartFactory = new PieChartFactory();
const radarChartFactory = new RadarChartFactory();

const barChart = barChartFactory.createChart();
const pieChart = pieChartFactory.createChart();
const radarChart = radarChartFactory.createChart();

barChart.render(); // 渲染柱状图
pieChart.render(); // 渲染饼状图
radarChart.render(); // 渲染雷达图
```

### 抽象工厂模式

> 简单工厂的确非常简单，但是可扩展性和灵活性都比较差，因为当需要添加新的产品时，需要修改工厂类的代码，这违反了开闭原则。同时，简单工厂的颗粒度比较粗，只能创建一类产品。
>
> 工厂方法模式通过将产品的创建交给子类来实现，避免了工厂类的修改，扩展性和灵活性都得到了提升。但是，工厂方法模式也存在一些问题，比如当产品种类非常多时，需要创建大量的工厂类，增加了系统的复杂度。
>
> 抽象工厂模式在工厂方法模式的基础上进行了进一步的抽象，它不仅负责创建一个产品，而是负责创建一族产品。抽象工厂将工厂的方法抽象成了一个接口或抽象类，让具体的工厂来实现创建一族产品的方法。这样，在需要添加新的产品时，只需要添加一个新的产品族和一个新的工厂类即可，不需要修改原有的代码，符合开闭原则。同时，抽象工厂也避免了工厂方法模式中创建大量工厂类的问题。

> 抽象工厂模式, 将不同产品再向上抽取一层, 形成不同的产品簇
>
> 比如之前的例子, 渲染柱状图,饼状图, 雷达图. 可以向上抽取成渲染2d图, 然后一些渲染地球球体, 渲染立体房子..向上抽取成渲染3d图
>
> 而与之对应的工厂的职责也变得不同, 工厂之前值渲染柱状图或是其他什么图, 现在渲染一个产品簇, 比如一个工厂创建渲染2d图的工作, 一个工厂创建3d的工作. 
>
> 而在工厂的内部, 再通过方法进行拆分, 一个方法创建一个产品簇的某一个具体的产品.

```typescript
// 图形接口
interface Graph { 
  render():void
}
// 2D图表接口
interface ChartGraph extends Graph { 
  x: number
  y:number
}

// 3D图形接口
interface ThreeDGraph extends Graph { 
  x: number
  y: number
  z: number
}
// 2D图表产品簇
class BarChart implements ChartGraph {
  constructor(public x: number, public y: number) {}
  
  render(): void {
    console.log('渲染柱状图');
  }
}

class PieChart implements ChartGraph {
  constructor(public x: number, public y: number) {}
  
  render(): void {
    console.log('渲染饼状图');
  }
}
// 3D图形产品簇
class Earth3D implements ThreeDGraph { 
  constructor(public x: number, public y: number, public z: number) {}

  render(): void {
    console.log("地球3d图形实现")
  }
}

class CityBuild3D implements ThreeDGraph { 
  constructor(public x: number, public y: number, public z: number) {}

  render(): void {
    console.log("城市3d立体图形实现")
  }
}

// 2D工厂
class TwoDFactory { 
  createPie(): PieChart { 
    return new PieChart(0, 0)
  }

  createBar(): BarChart { 
    return new BarChart(0, 0)
  }
}

// 3D工厂
class ThreeDFactory { 
  createEarth(): Earth3D { 
    return new Earth3D(0, 0, 0)
  }

  createCity3D(): CityBuild3D { 
    return new CityBuild3D(0, 0, 0)
  }
}
```

## 状态模式

> 状态模式（State Pattern）是一种设计模式，它允许对象在其内部状态发生变化时改变其行为。状态模式是一种行为型模式，它将对象的行为封装在不同的状态对象中，从而使得对象在运行时可以根据其内部状态而改变行为，而不需要使用大量的条件判断语句。

### 状态模式与订单系统

> 在订单系统中, 订单的状态可能有很多 "待支付" "已支付" "待收获" "已收货". 而且随着业务的增进, 也有可能出现更多的状态, 比如"已使用优惠券" "618折扣订单"等.... 这时候使用状态模式很好
>
> 状态模式允许对象在状态改变的时候, 做副作用. 

```typescript
interface State {
  order:Order
  handle():void
}

class PendingPaymentState implements State {
  constructor(public order:Order) { }
  handle(): void {
    console.log('正在支付...');
    this.order.setState(this.order.paidState) // 切换状态
  }
}

class PaidState implements State {
  constructor(public order:Order) { }
  handle(): void {
    console.log('正在付款...');
    this.order.setState(this.order.pendingTakeState) // 切换状态
  }
 }

class PendingTakeState implements State {
  constructor(public order:Order) { }
  handle(): void {
    console.log('正在收货...');
    this.order.setState(this.order.takedGoodsState) // 切换状态
  }
 }

class TakedGoodsState implements State {
  constructor(public order:Order) { }
  handle(): void {
    console.log('收货完成....');
    this.order.setState(this.order.pendingPaymentState) // 切换状态
  }
 }

class Order {
   pendingPaymentState = new PendingPaymentState(this)
   paidState = new PaidState(this)
   pendingTakeState = new PendingPaymentState(this)
   takedGoodsState = new TakedGoodsState(this)

  private currentState: State = this.pendingPaymentState

  // 支付接口
  makePayment(): void { 
    this.currentState = this.pendingPaymentState
    this.currentState.handle()
  }
  // 收货接口
  takeGoods(): void { 
    this.currentState = this.pendingTakeState
    this.currentState.handle()
  }

  setState(state: State) {
    this.currentState = state
  }
  
  getCurrentState() { 
    return this.currentState
  }
}
```

## 适配器模式

> 适配器模式（Adapter Pattern）是一种结构型设计模式，它允许将一个已存在的接口转化为客户端需要的接口，以解决接口不兼容的问题。适配器模式通过封装一个类，将客户端的请求转化为另一个接口，从而使得不兼容的接口可以协同工作。

### 适配器模式的前端应用

> 前端中适配器模式十分常见
>
> 我们从后端拉取数据, 渲染到页面上这个过程中, 经常会遇到后端给的数据多了, 给的数据的字段和组件库要的字段不一致, 或者你所需要的数据来源于两个接口请求, 需要手动合并的情况
>
> 这时候就可以使用适配器模式, 将后端的接口转成组件库要的接口

```typescript
// 后端数据接口
interface PersonData {
  id:string
  name:string
  gender:0 | 1
  age:number
}
// 请求方法, 拉取后端数据
const getPersons = ():Promise<PersonData[]> => {
  const response = axios({
    method:'get',
    url: 'xxxx'
  })
  return response.data
}

// 前端页面组件, react编写
import {useState,useEffect} from 'react'
import { Table } from "antd";

// antd要的表格数据
interface TableData  {
  key: number;
  name: string;
  age: number;
  gender: string;
}

// 适配器, 将后端数据转为前端数据
// 不一定用类实现, 用函数更简单.
class PersonsAdaptor {
  static adapt(persons:PersonData[]):TableData[]{
    return persons.map((person) => ({
      key: person.id,
      name:person.name,
      age:person.age,
      gender:person.age === 0 ? '男':'女'
    }))
  }
}

const App = () => {
  const [persons,setPersons] = useState([])
  const colums = [
      {
      title: "姓名",
      dataIndex: "name",
      key: "name",
    },
    {
      title: "年龄",
      dataIndex: "age",
      key: "age",
    },
    {
      title: "性别",
      dataIndex: "gender",
      key: "gender",
    },
  ]
  const getPersons = async () => {
    let persons = await getPersons()
    persons = PersonsAdaptor.adapt(persons) //适配器转换接口
    setPersons(persons)
  }
  
  useEffect(() => {
    getPersons()
  },[])
  
  return <Table datasource={persons} colums={colums}>  </Table>
}
```

